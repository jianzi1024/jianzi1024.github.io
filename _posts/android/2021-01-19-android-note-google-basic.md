---
layout: post
title: 学习笔记 - Google官方文档 - 应用基础知识
author: 贱子
date: 2021-01-19
tags: [Android]
---

学习笔记 - Google官方文档 - 应用基础知识 <!--more-->

## 应用基础知识

1. Android 操作系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户。
2. 默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID（该 ID 仅由系统使用，应用并不知晓）。系统会为应用中的所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件。
3. 每个进程都拥有自己的虚拟机 (VM)，因此应用代码独立于其他应用而运行。
4. 默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 系统会在需要执行任何应用组件时启动该进程，然后当不再需要该进程或系统必须为其他应用恢复内存时，其便会关闭该进程。
5. 广播接收器不会显示界面，但其可以创建状态栏通知，在发生广播事件时提醒用户。
6. 如果未在清单文件中声明源代码中包含的 Activity、服务和内容提供程序，则这些组件对系统不可见，因此也永远不会运行。不过，您可以 `BroadcastReceiver` 对象的形式，在清单中声明或在代码中动态创建广播接收器；以及通过调用 `registerReceiver()`，在系统中注册广播接收器。
7. 如果您使用 Intent 来启动 Service，请使用显式 Intent 来确保应用的安全性。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。请勿为您的服务声明 Intent 过滤器。
8. 以防将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为该应用支持的设备类型明确定义一个配置文件。其中的大多数声明只是为了提供信息，系统并不会读取它们，但 Google Play 等外部服务会读取它们，以便在用户通过其设备搜索应用时为用户提供过滤功能。

## 应用资源

### 概览

1. 项目 `res/` 目录中支持的资源目录。

   > 切勿将资源文件直接保存在 `res/` 目录内，因为这样会造成编译错误。

   | 目录        | 资源类型                                                     |
   | :---------- | :----------------------------------------------------------- |
   | `animator/` | 用于定义属性动画的 XML 文件。                                |
   | `anim/`     | 用于定义渐变动画的 XML 文件。（属性动画也可保存在此目录中，但为了区分这两种类型，属性动画首选 animator/ 目录。） |
   | `color/`    | 用于定义颜色状态列表的 XML 文件。                            |
   | `drawable/` | 位图文件（`.png`、`.9.png`、`.jpg`、`.gif`）或编译为以下可绘制对象资源子类型的 XML 文件：<br/>位图文件<br/>九宫格（可调整大小的位图）<br/>状态列表<br/>形状动画<br/>可绘制对象<br/>其他可绘制对象 |
   | `mipmap/`   | 适用于不同启动器图标密度的可绘制对象文件。                   |
   | `layout/`   | 用于定义用户界面布局的 XML 文件。                            |
   | `menu/`     | 用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。 |
   | `raw/`      | 需以原始形式保存的任意文件。如要使用原始 `InputStream` 打开这些资源，请使用资源 ID（即 `R.raw.filename`）调用 `Resources.openRawResource()`。但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 `assets/` 目录（而非 `res/raw/`）下。`assets/` 中的文件没有资源 ID，因此您只能使用 `AssetManager` 读取这些文件。 |
   | `values/`   | 包含字符串、整型数和颜色等简单值的 XML 文件。其他 res/ 子目录中的 XML 资源文件会根据 XML 文件名定义单个资源，而 values/ 目录中的文件可描述多个资源。对于此目录中的文件，<resources> 元素的每个子元素均会定义一个资源。例如，<string> 元素会创建 R.string 资源，<color> 元素会创建 R.color 资源。由于每个资源均使用自己的 XML 元素进行定义，因此您可以随意命名文件，并在某个文件中放入不同的资源类型。但是，您可能需要将独特的资源类型放在不同的文件中，使其一目了然。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：<br/>arrays.xml：资源数组（类型数组）。<br/>colors.xml：颜色值。<br/>dimens.xml：尺寸值。<br/>strings.xml：字符串值。<br/>styles.xml：样式。 |
   | `xml/`      | 可在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（如可搜索配置）都必须保存在此处。 |
   | `font/`     | 带有扩展名的字体文件（如 `.ttf`、`.otf` 或 `.ttc`），或包含 `<font-family>` 元素的 XML 文件。 |

2. 几乎每个应用都应提供备用资源，以便支持特定的设备配置。

   1. 在 `res/` 中创建以 *`<resources_name>-<config_qualifier>`* 形式命名的新目录。

      - *`<resources_name>`* 是相应默认资源的目录名称（如表 1 中所定义）。
      - *`<qualifier>`* 是指定要使用这些资源的各个配置的名称（如表 2 中所定义）。

      您可以追加多个 *`<qualifier>`*。以短划线将其分隔。

      > 追加多个限定符时，必须按照下表中列出的相同顺序放置限定符。如果限定符的顺序错误，则该资源将被忽略。

   2. 将相应的备用资源保存在此新目录下。这些资源文件必须与默认资源文件完全同名。

   | 配置                 | 限定符值                                                     | 描述                                                         |
   | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
   | 语言和区域           | 示例： `en` `fr` `en-rUS` `fr-rFR` `fr-rCA` `b+en` `b+en+US` `b+es+419` | 语言通过由两个字母组成的 ISO 639-1 语言代码进行定义，可以选择后跟两个字母组成的 ISO 3166-1-alpha-2 区域码（前缀用小写字母 r）。这些代码不区分大小写；r 前缀用于区分区域码。您不能单独指定区域。Android 7.0（API 级别 24）引入对 BCP 47 语言标记的支持，可供您用来限定特定语言和区域的资源。语言标记由一个或多个子标记序列组成，每个子标记都能优化或缩小由整体标记标识的语言范围。如果用户在系统设置中更改语言，则语言标记可能会在应用的生命周期中发生变更。 |
   | 布局方向             | `ldrtl` `ldltr`                                              | 应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr 是指“布局方向从左到右”（默认的隐式值）。此配置适用于布局、可绘制资源或值等任何资源。请注意：如要为应用启用从右到左的布局功能，则必须将 `supportsRtl` 设置为 "true"，并将 targetSdkVersion 设置为 17 或更高版本。此项为 API 级别 17 中的新增配置。 |
   | smallestWidth        | `sw<N>dp`  示例： `sw320dp` `sw600dp` `sw720dp`              | 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。具体而言，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用界面的可用宽度至少为 `<N>` dp。例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 `res/layout-sw600dp/`。仅当可用屏幕的最小尺寸至少为 600dp（无论 600dp 表示的边是用户所认为的高度还是宽度）时，系统才会使用这些资源。最小宽度为设备的固定屏幕尺寸特征；**即使屏幕方向发生变化，设备的最小宽度仍会保持不变**。使用最小宽度确定一般屏幕尺寸非常有用，因为宽度通常是设计布局时的驱动因素。界面经常会垂直滚动，但对其水平方向所需要的最小空间具有非常硬性的限制。可用宽度也是确定是否对手持式设备使用单窗格布局，或对平板电脑使用多窗格布局的关键因素。因此，您可能最关注每台设备上的最小可能宽度。设备的最小宽度会将屏幕装饰元素和系统界面考虑在内。例如，如果设备屏幕上的某些永久性界面元素沿着最小宽度轴占据空间，则系统会声明最小宽度小于实际屏幕尺寸，因为这些屏幕像素不适用于您的界面。以下是一些可用于常见屏幕尺寸的值：<br/>320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）<br/>480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。<br/>600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。<br/>720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。<br/>当应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。*此项为 API 级别 13 中的新增配置。* |
   | 可用宽度             | `w<N>dp`  示例： `w720dp` `w1024dp` 等等                     | 指定资源应使用的最小可用屏幕宽度（以 `dp` 为单位，由 `<N>` 值定义）。当屏幕方向在横向和纵向之间切换时，此配置值也会随之变化，以匹配当前的实际宽度。此功能往往有助于确定是否使用多窗格布局，因为即便在使用平板电脑设备时，您通常也不希望竖屏以横屏的方式使用多窗格布局。因此，您可以使用此功能指定布局所需的最小宽度，而无需同时使用屏幕尺寸和屏幕方向限定符。应用为此配置提供具有不同值的多个资源目录时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。此处的值会考虑屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，设备会使用小于实际屏幕尺寸的宽度值。*此项为 API 级别 13 中的新增配置。* |
   | 可用高度             | `h<N>dp`  示例： `h720dp` `h1024dp` 等等                     | 指定资源应使用的最小可用屏幕高度（以“dp”为单位，由 `<N>` 值定义）。当屏幕方向在横向和纵向之间切换时，此配置值也会随之变化，以匹配当前的实际高度。对比使用此方式定义布局所需高度与使用 `w<N>dp` 定义所需宽度，二者均非常有用，且都无需同时使用屏幕尺寸和方向限定符。但大多数应用不需要此限定符，因为界面经常垂直滚动，所以高度需更有弹性，而宽度则应更固定。当应用为此配置提供具有不同值的多个资源目录时，系统会使用最接近（但未超出）设备当前屏幕高度的值。此处的值会考虑屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，设备会使用小于实际屏幕尺寸的高度值。非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并*不*在考虑范围内，标题栏或操作栏等窗口装饰亦如此，因此应用必须准备好处理稍小于其指定值的空间。*此项为 API 级别 13 中的新增配置。* |
   | 屏幕尺寸             | `small` `normal` `large` `xlarge`                            | small：尺寸类似于低密度 VGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。<br/>normal：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。<br/>large：尺寸类似于中等密度 VGA 屏幕的屏幕。大屏幕的最小布局尺寸约为 480x640 dp。例如，VGA 和 WVGA 中等密度屏幕。<br/>xlarge：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp。在大多数情况下，屏幕超大的设备体积太大，不能放进口袋，最常见的是平板式设备。此项为 API 级别 9 中的新增配置。请注意：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能会使用其中最匹配的资源。注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不会使用这些资源，并且应用将在运行时崩溃（例如，如果所有布局资源均以 xlarge 限定符标记，但设备是标准尺寸的屏幕）。此项为 API 级别 4 中的新增配置。 |
   | 圆形屏幕             | `round` `notround`                                           | `round`：圆形屏幕，例如圆形可穿戴式设备<br/>`notround`：方形屏幕，例如手机或平板电脑<br/>*此项为 API 级别 23 中的新增配置。* |
   | 屏幕方向             | `port` `land`                                                | `port`：设备处于纵向（垂直）<br/>`land`：设备处于横向状态（水平）<br/>如果用户旋转屏幕，此配置可能会在应用生命周期中发生变化。 |
   | 夜间模式             | `night` `notnight`                                           | `night`：夜间<br/>`notnight`：白天<br/>*此项为 API 级别 8 中的新增配置。*如果夜间模式停留在自动模式（默认），此配置可能会在应用生命周期中发生变化。在此情况下，该模式会根据当天的时间进行调整。您可以使用 `UiModeManager` 启用或禁用此模式。 |
   | 屏幕像素密度 (dpi)   | `ldpi` `mdpi` `hdpi` `xhdpi` `xxhdpi` `xxxhdpi` `nodpi` `tvdpi` `anydpi` `*nnn*dpi` | ldpi：低密度屏幕；约为 120dpi。<br/>mdpi：中等密度（传统 HVGA）屏幕；约为 160dpi。<br/>hdpi：高密度屏幕；约为 240dpi。<br/>xhdpi：超高密度屏幕；约为 320dpi。此项为 API 级别 8 中的新增配置<br/>xxhdpi：绝高密度屏幕；约为 480dpi。此项为 API 级别 16 中的新增配置<br/>xxxhdpi：极高密度屏幕使用（仅限启动器图标）；约为 640dpi。此项为 API 级别 18 中的新增配置<br/>nodpi：可用于您不希望为匹配设备密度而进行缩放的位图资源。<br/>tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。此限定符并非指“基本”密度的屏幕。它主要用于电视，且大多数应用都不使用该密度 — 大多数应用只会使用 mdpi 和 hdpi 资源，而且系统将根据需要对这些资源进行缩放。*此项为 API 级别 13 中的新增配置*<br/>anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。这非常适用于矢量可绘制对象。*此项为 API 级别 21 中的新增配置*<br/>*nnn*dpi：用于表示非标准密度，其中 *nnn* 是正整数屏幕密度。此限定符不适用于大多数情况。使用标准密度存储分区，可显著减少因支持市场上各种设备屏幕密度而产生的开销。<br/>六个基本密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。如果您认为图像资源在电视或其他某些设备上的呈现效果不够好，进而想尝试使用 tvdpi 资源，则缩放系数应为 1.33mdpi。例如，mdpi 屏幕的 100px x 100px 图像应相当于 tvdpi 屏幕的 133px x 133px 图像。<br/>请注意：使用密度限定符并不表示资源*仅*适用于该密度的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。 |
   | 平台版本（API 级别） | 示例： `v3` `v4` `v7` 等等                                   | 设备支持的 API 级别。例如，`v1` 对应 API 级别 1（装有 Android 1.0 或更高版本系统的设备），`v4` 对应 API 级别 4（装有 Android 1.6 或更高版本系统的设备）。 |
   
3. 编译应用时，`aapt` 会生成 `R` 类，其中包含 `res/` 目录中所有资源的资源 ID。每个资源类型都有对应的 `R` 子类（例如，`R.drawable` 对应所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，`R.drawable.icon`）。该整型数就是可用来检索资源的资源 ID。

4. 系统使用以下逻辑决定要使用的资源：

   1. 淘汰与设备配置冲突的资源文件。
   2. 选择列表中（下一个）优先级最高的限定符。
   3. 是否有资源目录包含此限定符？
      1. 若无，请返回到第 2 步，看看下一个限定符。
      2. 若有，请继续执行第 4 步。
   4. 淘汰不含此限定符的资源目录。
   5. 返回并重复第 2 步、第 3 步和第 4 步，直到仅剩一个目录为止。

5. 在根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，必要时，大尺寸屏幕将使用标准尺寸的屏幕资源）。但是，如果唯一可用的资源*大于*当前屏幕，则系统**不会**使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 `xlarge` 限定符标记，但设备是标准尺寸的屏幕）。

### 处理配置变更

1. 某些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性，以及当用户启用多窗口模式时）。发生这种变化时，Android 会重启正在运行的 `Activity`（先后调用 `onDestroy()` 和 `onCreate()`）。
2. 如要妥善处理重启行为，Activity 必须恢复其先前的状态。您可以同时使用 `onSaveInstanceState()`、`ViewModel` 对象以及持久存储，以在配置变更时保存并恢复 `Activity` 的界面状态。
3. 如要声明由 Activity 处理配置变更，请在清单文件中编辑相应的 `<activity>` 元素，以包含 `android:configChanges` 属性，该属性的值表示要处理的配置。`android:configChanges` 属性文档中列出该属性的可能值。最常用的值包括 `"orientation"`、`"screenSize"` 和 `"keyboardHidden"`。`"orientation"` 值可在屏幕方向发生变更时阻止重启。`"screenSize"` 值也可在屏幕方向发生变更时阻止重启，但仅适用于 Android 3.2（API 级别 13）及以上版本的系统。若想在应用中手动处理配置变更，您必须在 `android:configChanges` 属性中声明 `"orientation"` 和 `"screenSize"` 值。`"keyboardHidden"` 值可在键盘可用性发生变更时阻止重启。您可以在属性中声明多个配置值，方法是用管道 `|` 字符将其进行分隔。
4. 现在，即便其中某个配置发生变化，`MyActivity` 也不会重启。但 `MyActivity` 会接收到对 `onConfigurationChanged()` 的调用消息。此方法会收到传递的 `Configuration` 对象，从而指定新设备配置。您可以通过读取 `Configuration` 中的字段确定新配置，然后通过更新界面所用资源进行适当的更改。调用此方法时，Activity 的 `Resources` 对象会相应地进行更新，并根据新配置返回资源，以便您在系统不重启 Activity 的情况下轻松重置界面元素。

### 资源类型

`TODO` 尚未阅读

## 应用清单文件

### activity

1. `android:allowTaskReparenting`

   当下一次将启动 Activity 的任务转至前台时，Activity 是否能从该任务转移至与其有相似性的任务 —“`true`”表示可以转移，“`false`”表示仍须留在启动它的任务处。

   如果未设置该属性，则对 Activity 应用由 `<application>` 元素的相应 `allowTaskReparenting` 属性所设置的值。默认值为“`false`”。

   正常情况下，Activity 启动时会与启动它的任务关联，并在其整个生命周期中一直留在该任务处。当不再显示现有任务时，您可以使用该属性强制 Activity 将其父项更改为与其有相似性的任务。该属性通常用于将应用的 Activity 转移至与该应用关联的主任务。

   例如，如果电子邮件消息包含网页链接，则点击该链接会调出可显示该网页的 Activity。该 Activity 由浏览器应用定义，但作为电子邮件任务的一部分启动。如果将该 Activity 的父项更改为浏览器任务，则它会在浏览器下一次转至前台时显示，在电子邮件任务再次转至前台时消失。

   Activity 的相似性由 `taskAffinity` 属性定义。通过读取任务根 Activity 的相似性即可确定任务的相似性。因此，按照定义，根 Activity 始终位于具有同一相似性的任务中。由于具有“`singleTask`”或“`singleInstance`”启动模式的 Activity 只能位于任务的根，因此更改父项仅限于“`standard`”和“`singleTop`”模式。

2. `android:alwaysRetainTaskState`

   系统是否始终保持 Activity 所在任务的状态 —“`true`”表示是，“`false`”表示允许系统在特定情况下将任务重置到其初始状态。默认值为“`false`”。该属性只对任务的根 Activity 有意义；所有其他 Activity 均可忽略该属性。

   正常情况下，当用户从主屏幕重新选择某个任务时，系统会在特定情况下清除该任务（从根 Activity 上的堆栈中移除所有 Activity）。通常，如果用户在一段时间（如 30 分钟）内未访问任务，系统会执行此操作。

   不过，如果该属性的值是“`true`”，则无论用户如何返回任务，该任务始终会显示最后一次的状态。例如，该属性非常适用于网络浏览器这类应用，因为其中存在大量用户不愿丢失的状态（如多个打开的标签）。

3. `android:autoRemoveFromRecents`

   由具有该属性的 Activity 启动的任务是否一直保留在概览屏幕中，直至任务中的最后一个 Activity 完成为止。若为 true，则自动从概览屏幕中移除任务。它会替换调用方使用的 FLAG_ACTIVITY_RETAIN_IN_RECENTS。它必须是布尔值“true”或“false”。

4. `android:clearTaskOnLaunch`

   每当从主屏幕重新启动任务时，是否都从该任务中移除根 Activity 之外的所有 Activity —“`true`”表示始终将任务清除至只剩其根 Activity；“`false`”表示不清除。默认值为“`false`”。该属性只对启动新任务的 Activity（根 Activity）有意义；任务中的所有其他 Activity 均可忽略该属性。

   若值为“`true`”，则每次当用户再次启动任务时，无论用户最后在任务中正在执行哪个 Activity，也无论用户是使用*返回*还是*主屏幕*按钮离开，系统都会将用户转至任务的根 Activity。当值为“`false`”时，可在某些情况下清除任务中的 Activity，但也有例外。

   如果该属性和 `allowTaskReparenting` 的值均为“`true`”，则如上所述，任何可更改父项的 Activity 都将转移至与其有相似性的任务；而其余 Activity 随即会被移除。

5. `android:directBootAware`

   Activity 是否*支持直接启动*，即其是否可以在用户解锁设备之前运行。

   请注意：在直接启动期间，应用中的 Activity 仅可访问存储在设备保护存储区的数据。

   默认值为 `"false"`。

6. `android:excludeFromRecents`

   是否应从最近使用的应用列表（即概览屏幕）中排除该 Activity 启动的任务。换言之，当该 Activity 是新任务的根 Activity 时，此属性确定最近使用的应用列表中是否应出现该任务。如果应从列表中排除任务，请设置“true”；如果应将其包括在内，则设置“false”。默认值为“false”。

7. `android:exported`

   此元素设置 Activity 是否可由其他应用的组件启动 —“`true`”表示可以，“`false`”表示不可以。若为“`false`”，则 Activity 只能由同一应用的组件或使用同一用户 ID 的不同应用启动。

   如果您使用的是 Intent 过滤器，则不应将此元素设置为“`false`”。否则，在应用尝试调用 Activity 时，系统会抛出 `ActivityNotFoundException` 异常。相反，您不应为其设置 Intent 过滤器，以免其他应用调用 Activity。

   如果没有 Intent 过滤器，则此元素的默认值为“`false`”。如果您将元素设置为“`true`”，则任何知道其确切类名的应用均可访问 Activity，但在系统尝试匹配隐式 Intent 时，该 Activity 无法解析。

   此属性并非是限制 Activity 向其他应用公开的唯一方式。

8. `android:finishOnTaskLaunch`

   每当用户再次启动 Activity 的任务（在主屏幕上选择任务）时，是否应关闭（完成）现有的 Activity 实例 —“`true`”表示应关闭，“`false`”表示不应关闭。默认值为“`false`”。

   如果此属性和 `allowTaskReparenting` 均为“`true`”，则优先使用此属性。系统会忽略 Activity 的相似性。系统不会更改 Activity 的父项，而是将其销毁。

9. `android:immersive`

   为当前 Activity 进行沉浸模式设置。如果在应用清单文件条目中为此 Activity 将 `android:immersive` 属性设置为 `true`，则 `ActivityInfo.flags` 成员会始终设置其 `FLAG_IMMERSIVE` 位（即便在运行时使用 `setImmersive()` 方法更改沉浸模式）。

10. `android:launchMode`

    有关应如何启动 Activity 的指令。共有四种模式可与 `Intent` 对象中的 Activity 标记（`FLAG_ACTIVITY_*` 常量）协同工作，以确定在调用 Activity 处理 Intent 时应执行的操作。这些模式是：

    - “`standard`”
    - “`singleTop`”
    - “`singleTask`”
    - “`singleInstance`”

    默认模式是“`standard`”。

    如下表所示，这些模式可分为两大类：“`standard`”和“`singleTop`”Activity 为一类，“`singleTask`”和“`singleInstance`”Activity 为另一类。使用“`standard`”或“`singleTop`”启动模式的 Activity 可多次进行实例化。实例可归属任何任务，并且可位于 Activity 堆栈中的任何位置。通常，它们会启动到名为 `startActivity()` 的任务中（除非 Intent 对象包含 `FLAG_ACTIVITY_NEW_TASK` 指令，在此情况下会选择其他任务）。

    相比之下，“`singleTask`”和“`singleInstance`”Activity 只能启动任务。它们始终位于 Activity 堆栈的根位置。此外，设备一次只能保留一个 Activity 实例，即一次只允许一个此类任务。

    “`standard`”和“`singleTop`”模式只有一处不同：每次“`standard`”Activity 有新的 Intent 时，系统都会创建新的类实例来响应该 Intent。每个实例处理单个 Intent。同样地，您也可以创建新的“`singleTop`”Activity 实例来处理新的 Intent。不过，如果目标任务的 Activity 堆栈顶部已有一个 Activity 实例，则该实例会（通过调用 `onNewIntent()`）接收新的 Intent；此时不会创建新实例。在其他情况下（例如，如果“`singleTop`”Activity 的某个现有实例虽在目标任务内，但未处于堆栈顶部，或者虽然位于堆栈顶部，但不在目标任务中），系统会创建新实例并将其送入堆栈。

    同样地，如果您向上导航到当前堆栈上的某个 Activity，则该行为由父 Activity 的启动模式决定。如果父 Activity 有启动模式 singleTop（或者 up Intent 包含 FLAG_ACTIVITY_CLEAR_TOP），则系统会将该父项置于堆栈顶部，并保留其状态。导航 Intent 由父 Activity 的 onNewIntent() 方法接收。如果父 Activity 有启动模式 standard（并且 up Intent 不包含 FLAG_ACTIVITY_CLEAR_TOP），则系统会将当前 Activity 及其父项同时送出堆栈，并创建新的父 Activity 实例来接收导航 Intent。

    “`singleTask`”和“`singleInstance`”模式同样只有一处不同：“`singleTask`”Activity 允许其他 Activity 成为其任务的一部分。该 Activity 始终位于其任务的根位置，但其他 Activity（必然是“`standard`”和“`singleTop`”Activity）可以启动到该任务中。另一方面，“`singleInstance`”Activity 不允许其他 Activity 成为其任务的一部分。它是任务中唯一的 Activity。如果它启动另一个 Activity，则系统会将该 Activity 分配给其他任务，就如同 Intent 中包含 `FLAG_ACTIVITY_NEW_TASK` 一样。

    | 用例                                  | 启动模式       | 多个实例？                                                   | 注释                                                         |
    | :------------------------------------ | :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
    | 大多数 Activity 的正常启动            | “`standard`”   | 是                                                           | 默认。系统始终会在目标任务中创建新的 Activity 实例，并向其传送 Intent。 |
    | “`singleTop`”                         | 视情况而定     | 如果目标任务的顶部已存在 Activity 实例，则系统会通过调用该实例的 `onNewIntent()` 方法向其传送 Intent，而非创建新的 Activity 实例。 |                                                              |
    | 专用启动 *（不建议在一般情况下使用）* | “`singleTask`” | 否                                                           | 系统会在新任务的根位置创建 Activity 并向其传送 Intent。不过，如果已存在 Activity 实例，则系统会调用该实例的 `onNewIntent()` 方法（而非创建新的 Activity 实例），向其传送 Intent。 |
    | “`singleInstance`”                    | 否             | 与“`singleTask"`”相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务中的唯一 Activity。 |                                                              |

    如上表所示，`standard` 是默认模式，并且适用于大多数类型的 Activity。对众多类型的 Activity 而言，`SingleTop` 也是常见且有用的启动模式。其他模式（`singleTask` 和 `singleInstance`）不适用于大多数应用，因为它们所形成的交互模式可能让用户感到陌生，并且与大多数其他应用差别较大。

11. `android:multiprocess`

    是否可将 Activity 实例启动到启动该实例的组件进程内 —“`true`”表示可以，“`false`”表示不可以。默认值为“`false`”。

    正常情况下，新的 Activity 实例会启动到定义该实例的应用进程内，因此所有 Activity 实例都在同一进程内运行。不过，如果将该标记设置为“`true`”，则 Activity 实例便可在多个进程内运行，以便系统在任何使用实例的地方创建实例（前提是权限允许这样做），但这几乎毫无必要。

12. `android:noHistory`

    当用户离开 Activity 且屏幕上不再显示该 Activity 时，是否应从 Activity 堆栈中将其移除并完成（调用其 `finish()` 方法）—“`true`”表示应将其完成，“`false`”表示不应将其完成。默认值为“`false`”。

    “`true`”一值表示 Activity 不会留下历史跟踪记录。它不会留在任务的 Activity 堆栈内，因此用户将无法返回 Activity。在此情况下，如果您通过启动另一个 Activity 来获取该 Activity 的结果，系统永远不会调用 `onActivityResult()`。

13. `android:process`

    应在其中运行 Activity 的进程的名称。正常情况下，应用的所有组件均以为应用创建的默认进程名称运行，您无需使用该属性。但如有必要，您可以使用该属性替换默认进程名称，以便将应用组件散布到多个进程中。

    如果为该属性分配的名称以冒号（“:”）开头，则系统会在需要时创建应用专用的新进程，并且 Activity 会在该进程中运行。如果进程名称以小写字符开头，则 Activity 将在使用该名称的全局进程中运行，前提是它拥有相应的权限。如此一来，不同应用中的组件便可共享进程，从而减少资源使用。

    `<application>` 元素的 `process` 属性可为所有组件设置不同的默认进程名称。

14. `resizeableActivity`

    指定应用是否支持多窗口显示。您可以在 `<activity>` 或 `<application>` 元素中设置该属性。

    如果您将该属性设置为 true，则用户可以在分屏和自由窗口模式下启动 Activity。如果您将该属性设置为 false，则 Activity 不支持多窗口模式。如果该值为 false，且用户尝试在多窗口模式下启动 Activity，则该 Activity 将全屏显示。

    如果应用面向 API 级别 24 或更高级别，但您未指定该属性的值，则该属性的值默认设为 true。

    该属性是 API 级别 24 中的新增属性。

15. `android:screenOrientation`

    Activity 在设备上的显示方向。如果 Activity 是在多窗口模式下运行，则系统会忽略该属性。

    其值可以是下列任一字符串：

    | “`unspecified`”      | 默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文中所做的选择可能会有所差异。 |
    | -------------------- | ------------------------------------------------------------ |
    | “`behind`”           | 与 Activity 栈中紧接其后的 Activity 的方向相同。             |
    | “`landscape`”        | 屏幕方向为横向（显示的宽度大于高度）。                       |
    | “`portrait`”         | 屏幕方向为纵向（显示的高度大于宽度）。                       |
    | “`reverseLandscape`” | 屏幕方向是与正常横向方向相反的横向。*此项为 API 级别 9 中的新增配置。* |
    | “`reversePortrait`”  | 屏幕方向是与正常纵向方向相反的纵向。*此项为 API 级别 9 中的新增配置。* |
    | “`sensorLandscape`”  | 屏幕方向为横向，但可根据设备传感器调整为正常或反向的横向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。*此项为 API 级别 9 中的新增配置。* |
    | “`sensorPortrait`”   | 屏幕方向为纵向，但可根据设备传感器调整为正常或反向的纵向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。*此项为 API 级别 9 中的新增配置。* |
    | “`userLandscape`”    | 屏幕方向为横向，但可根据设备传感器和用户首选项调整为正常或反向的横向。*此项为 API 级别 18 中的新增配置。* |
    | “`userPortrait`”     | 屏幕方向为纵向，但可根据设备传感器和用户首选项调整为正常或反向的纵向。*此项为 API 级别 18 中的新增配置。* |
    | “`sensor`”           | 屏幕方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。但在默认情况下，一些设备不会旋转为所有四种可能的方向。如要支持所有这四种方向，请使用 `"fullSensor"`。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 |
    | “`fullSensor`”       | 屏幕方向由使用 4 种方向中任一方向的设备方向传感器决定。这与 `"sensor"` 类似，不同之处在于无论设备在正常情况下使用哪种方向，该值均支持所有 4 种可能的屏幕方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但其支持这些方向）。*此项为 API 级别 9 中的新增配置。* |
    | “`nosensor`”         | 确定屏幕方向时不考虑物理方向传感器。系统会忽略传感器，因此显示内容不会随用户手持设备的方向而旋转。 |
    | “`user`”             | 用户当前的首选方向。                                         |
    | “`fullUser`”         | 如果用户锁定基于传感器的旋转，则其行为与 `user` 相同，否则，其行为与 `fullSensor` 相同，并且支持所有 4 种可能的屏幕方向。*此项为 API 级别 18 中的新增配置。* |
    | “`locked`”           | 将屏幕方向锁定为其当前的任意旋转方向。*此项为 API 级别 18 中的新增配置。* |

16. `android:taskAffinity`

    与 Activity 有着相似性的任务。从概念上讲，具有同一相似性的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。任务的相似性由其根 Activity 的相似性确定。

    相似性确定两点内容 — Activity 更改父项后的任务（请参阅 `allowTaskReparenting` 属性），以及通过 `FLAG_ACTIVITY_NEW_TASK` 标记启动 Activity 时，用于容纳该 Activity 的任务。

    默认情况下，应用中的所有 Activity 都具有同一相似性。您可以设置该属性，以不同方式将其分组，甚至可以在同一任务内放置不同应用中定义的 Activity。如要指定 Activity 与任何任务均无相似性，请将其设置为空字符串。

    如果未设置该属性，则 Activity 会继承为应用设置的相似性（请参阅 `<application>` 元素的 `taskAffinity` 属性）。应用默认相似性的名称为 `<manifest>` 元素所设置的软件包名称。

17. `android:theme`

    对定义 Activity 总体主题的样式资源的引用。此属性会自动将 Activity 的场景设置为使用该主题，并且还可引发 Activity 启动前的“启动”动画（以更加符合 Activity 的实际外观）。

    如果未设置该属性，则 Activity 会继承通过 `<application>` 元素的 `theme` 属性为应用所整体设置的主题。如果同样未设置该属性，则使用默认系统主题。

18. `android:windowSoftInputMode`

    Activity 的主窗口与包含屏幕软键盘的窗口之间的交互方式。该属性的设置会影响两点内容：

    - 当 Activity 成为用户注意的焦点时，软键盘的状态为隐藏还是可见。
    - 对 Activity 主窗口所做的调整 — 是否将其尺寸调小，为软键盘腾出空间；或当软键盘遮盖部分窗口时，是否平移其内容以使当前焦点可见。

    该设置必须是下表所列的其中一项值，或一个“`state...`”值加上一个“`adjust...`”值的组合。在任一组中设置多个值（例如，多个“`state...`”值）均会产生未定义的结果。各值之间使用竖线 (`|`) 进行分隔。例如：

    ```xml
    <activity android:windowSoftInputMode="stateVisible|adjustResize" ... >
    ```

    以下设置的值（“`stateUnspecified`”和“`adjustUnspecified`”除外）会替换主题中设置的值。

    | 值                     | 描述                                                         |
    | :--------------------- | :----------------------------------------------------------- |
    | “`stateUnspecified`”   | 不指定软键盘的状态（隐藏还是可见）。系统会选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置。 |
    | “`stateUnchanged`”     | 当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏。 |
    | “`stateHidden`”        | 当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时）隐藏软键盘。 |
    | “`stateAlwaysHidden`”  | 当 Activity 的主窗口有输入焦点时始终隐藏软键盘。             |
    | “`stateVisible`”       | 在正常的适宜情况下（当用户向前导航到 Activity 的主窗口时）显示软键盘。 |
    | “`stateAlwaysVisible`” | 当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时）显示软键盘。 |
    | “`adjustUnspecified`”  | 不指定 Activity 的主窗口是否通过调整尺寸为软键盘腾出空间，或者是否通过平移窗口内容以在屏幕上显示当前焦点。根据窗口的内容是否存在任何可滚动其内容的布局视图，系统会自动选择其中一种模式。如果存在这种视图，系统会调整窗口尺寸，前提是可通过滚动操作在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置。 |
    | “`adjustResize`”       | 始终调整 Activity 主窗口的尺寸，以为屏幕上的软键盘腾出空间。 |
    | “`adjustPan`”          | 不通过调整 Activity 主窗口的尺寸为软键盘腾出空间。相反，窗口的内容会自动平移，使键盘永远无法遮盖当前焦点，以便用户始终能看到自己输入的内容。这通常不如调整窗口尺寸可取，因为用户可能需关闭软键盘才能进入被遮盖的窗口部分，并与之进行交互。 |

    该属性是 API 级别 3 中的新增属性。

### 其他

`TODO` 尚未阅读