---
layout: post
title: JavaScript入门教程学习笔记
date: 2021-05-07
author: 贱子
tags: [JavaScript]
---

## 发展历史

- 1997年7月，ECMAScript 1.0发布。
- 1998年6月，ECMAScript 2.0版发布。
- 1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。
- 2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。
- 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。
- 2009年12月，ECMAScript 5.0版 正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。
- 2011年6月，ECMAScript 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。
- 2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。
- 2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。
- 2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为“ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。

## 基本语法

- 如果使用`var`重新声明一个已经存在的变量，是无效的。
- JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。

## 数据类型

- `typeof`运算符可以返回一个值的数据类型。
  - 数值、字符串、布尔值分别返回`number`、`string`、`boolean`。
  - 函数返回`function`。
  - `undefined`返回`undefined`。
  - 对象返回`object`。
  - `null`返回`object`。
- `undefined`和`null`，在`if`语句中，它们都会被自动转为`false`，相等运算符（`==`）甚至直接报告两者相等。
- 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为`false`，其他值都视为`true`。
  - `undefined`
  - `null`
  - `false`
  - `0`
  - `NaN`
  - `""`或`''`（空字符串）
- `NaN`不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于`Number`，使用`typeof`运算符可以看得很清楚。`NaN`不等于任何值，包括它本身。
- `Infinity`大于一切数值（除了`NaN`），`-Infinity`小于一切数值（除了`NaN`）。`Infinity`与`NaN`比较，总是返回`false`。

### 对象

- 查看一个对象本身的所有属性，可以使用`Object.keys`方法。
- `delete`命令用于删除对象的属性，删除成功后返回`true`。删除一个不存在的属性，`delete`不报错，而且返回`true`。`delete`命令只能删除对象本身的属性，无法删除继承的属性。
- `in`运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。它的左边是一个字符串，表示属性名，右边是一个对象。
- 可以使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。
- `for...in`循环用来遍历一个对象的全部属性。
  - 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
  - 它不仅遍历对象自身的属性，还遍历继承的属性。
- 如果`with`区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。`with`语句的格式如下，它的作用是操作同一个对象的多个属性时，提供一些书写的方便。（不建议使用）

```javascript
with (对象) {
  语句;
}
var obj = {
  p1: 1,
  p2: 2,
};
with (obj) {
  p1 = 4;
  p2 = 5;
}
// 等同于
obj.p1 = 4;
obj.p2 = 5;
```

### 函数

- 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。

- 函数的`name`属性返回函数的名字。如果是通过变量赋值定义的函数，那么`name`属性返回变量名。

- 函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。

- 函数的`toString()`方法返回一个字符串，内容是函数的源码。

- 对于`var`命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。

- 与全局作用域一样，函数作用域内部也会产生“变量提升”现象。`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

- 如果有同名的参数，则取最后出现的那个值。函数`f()`有两个参数，且参数名都是`a`。取值的时候，以后面的`a`为准，即使后面的`a`没有值或被省略，也是以其为准。

- `arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。

- 严格模式下，`arguments`对象与函数参数不具有联动关系。也就是说，修改`arguments`对象不会影响到实际的函数参数。

- `arguments`对象带有一个`callee`属性，返回它所对应的原函数。

- 闭包就是能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如`f2`记住了它诞生的环境`f1`，所以从`f2`可以得到`f1`的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

- 闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。

- 闭包的另一个用处，是封装对象的私有属性和私有方法。

- 外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

- 为了避免解析的歧义，JavaScript 规定，如果`function`关键字出现在行首，一律解释成语句。因此，引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，不能直接调用，所以就报错了。

  函数定义后立即调用的解决方法，就是不要让`function`出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。

### 数组

- `length`属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到`length`设置的值。
- 清空数组的一个有效方法，就是将`length`属性设为0。
- 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响`length`属性的值。将数组的键分别设为字符串和小数，结果都不影响`length`属性。因为，`length`属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以`length`属性保持为`0`。
- 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。
- `for...in`不仅会遍历数组所有的数字键，还会遍历非数字键。
- 数组如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。
- “类似数组的对象”的根本特征，就是具有`length`属性。只要有`length`属性，就可以认为这个对象类似于数组。但是有一个问题，这种`length`属性不是动态值，不会随着成员的变化而变化。

## 运算符

### 算数运算符

- 指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。
- 指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。

### 比较运算符

- 对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

- 任何值（包括`NaN`本身）与`NaN`使用非相等运算符进行比较，返回的都是`false`。

- 如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法。

- `undefined`和`null`与自身严格相等。

- ```javascript
  undefined == undefined // true
  null == null // true
  undefined == null // true
  ```

## 语法专题

### 数据类型的转换

- 使用`Number`函数，可以将任意类型的值转化成数值。

  - `Number`函数将字符串转为数值，要比`parseInt`函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`。
  - `parseInt`逐个解析字符，而`Number`函数整体转换字符串的类型。
  - `parseInt`和`Number`函数都会自动过滤一个字符串前导和后缀的空格。
  - `Number`方法的参数是对象时，将返回`NaN`，除非是包含单个数值的数组。

- `String`函数可以将任意类型的值转化成字符串。

- `Boolean()`函数可以将任意类型的值转为布尔值。

- ```javascript
  Boolean(false) // false
  Boolean(new Boolean(false)) // true
  ```

### 错误处理机制

- `Error()`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。抛出`Error`实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。
- 大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。
  - **message**：错误提示信息
  - **name**：错误名称（非标准属性）
  - **stack**：错误的堆栈（非标准属性）
- `SyntaxError`对象是解析代码时发生的语法错误。
- `ReferenceError`对象是引用一个不存在的变量时发生的错误。
- `RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。
- `TypeError`对象是变量或参数不是预期类型时发生的错误。
- `URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。
- `throw`语句的作用是手动中断程序执行，抛出一个错误。`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。
- `try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。
- 没有`catch`语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行`finally`代码块，然后再向用户提示报错信息。
- `return`语句的执行是排在`finally`代码之前，只是等`finally`代码执行完毕后才返回。

### console 对象与控制台

- `dir`方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。

- `console.assert`方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。

  它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为`false`，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。

- `time`方法表示计时开始，`timeEnd`方法表示计时结束。它们的参数是计时器的名称。调用`timeEnd`方法之后，控制台会显示“计时器名称: 所耗费的时间”。

## 标准库

### Object对象

- 虽然用法相似，但是`Object(value)`与`new Object(value)`两者的语义是不同的，`Object(value)`表示将`value`转成一个对象，`new Object(value)`则表示新生成一个对象，它的值是`value`。
- 静态方法
  - `Object.keys`方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。
  - `Object.getOwnPropertyNames`方法与`Object.keys`类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。
  - `Object.keys`方法只返回可枚举的属性，`Object.getOwnPropertyNames`方法还返回不可枚举的属性名。
- 实例方法
  - `valueOf`方法的作用是返回一个对象的“值”，默认情况下返回对象本身。`valueOf`方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。
  - `toString`方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。
  - `hasOwnProperty`方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。

### 属性描述对象

- JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。

  - `value`是该属性的属性值，默认为`undefined`。
  - `writable`是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为`true`。如果原型对象的某个属性的`writable`为`false`，那么子对象将无法自定义这个属性。
  - `enumerable`是一个布尔值，表示该属性是否可遍历，默认为`true`。如果设为`false`，会使得某些操作（比如`for...in`循环、`Object.keys()`）跳过该属性。如果一个属性的`enumerable`为`false`，下面三个操作不会取到该属性。
    - `for..in`循环
    - `Object.keys`方法
    - `JSON.stringify`方法
  - `configurable`是一个布尔值，表示可配置性，默认为`true`。如果设为`false`，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（`value`属性除外）。也就是说，`configurable`属性控制了属性描述对象的可写性。`writable`只有在`false`改为`true`会报错，`true`改为`false`是允许的。
  - `get`是一个函数，表示该属性的取值函数（getter），默认为`undefined`。
  - `set`是一个函数，表示该属性的存值函数（setter），默认为`undefined`。

- `Object.getOwnPropertyDescriptor()`方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。只能用于对象自身的属性，不能用于继承的属性。

- `Object.defineProperty()`方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。

  ```javascript
  var obj = Object.defineProperty({}, 'p', {
    value: 123,
    writable: false,
    enumerable: true,
    configurable: false
  });
  ```

- 如果一次性定义或修改多个属性，可以使用`Object.defineProperties()`方法。

  ```javascript
  var obj = Object.defineProperties({}, {
    p1: { value: 123, enumerable: true },
    p2: { value: 'abc', enumerable: true },
    p3: { get: function () { return this.p1 + this.p2 },
      enumerable:true,
      configurable:true
    }
  });
  ```

- 一旦定义了取值函数`get`（或存值函数`set`），就不能将`writable`属性设为`true`，或者同时定义`value`属性，否则会报错。

- `Object.defineProperty()`和`Object.defineProperties()`参数里面的属性描述对象，`writable`、`configurable`、`enumerable`这三个属性的默认值都为`false`。

- 实例对象的`propertyIsEnumerable()`方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回`false`。

- `Object.preventExtensions`方法可以使得一个对象无法再添加新的属性。

- `Object.isExtensible`方法用于检查一个对象是否使用了`Object.preventExtensions`方法。也就是说，检查是否可以为一个对象添加属性。

- `Object.seal`方法使得一个对象既无法添加新属性，也无法删除旧属性。`Object.seal`实质是把属性描述对象的`configurable`属性设为`false`，因此属性描述对象不再能改变了。

- `Object.isSealed`方法用于检查一个对象是否使用了`Object.seal`方法。

- `Object.freeze`方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。

- `Object.isFrozen`方法用于检查一个对象是否使用了`Object.freeze`方法。

- 使用`Object.freeze`方法以后，`Object.isSealed`将会返回`true`，`Object.isExtensible`返回`false`。

- 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。

- 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。

### Array对象

- `Array.isArray`方法返回一个布尔值，表示参数是否为数组。它可以弥补`typeof`运算符的不足。

- `join()`方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。

- `concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。

- `reverse`方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。

- `slice()`方法用于提取目标数组的一部分，返回一个新数组，原数组不变。

  ```javascript
  arr.slice(start, end);
  ```

  它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。

- `splice()`方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。

  ```javascript
  arr.splice(start, count, addElement1, addElement2, ...);
  ```

  `splice`的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。

- `map`方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。`map`方法接受一个函数作为参数。该函数调用时，`map`方法向它传入三个参数：当前成员、当前位置和数组本身。`map`方法不会跳过`undefined`和`null`，但是会跳过空位。

- `forEach`方法与`map`方法很相似，也是对数组的所有成员依次执行参数函数。但是，`forEach`方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用`map`方法，否则使用`forEach`方法。`forEach`方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用`for`循环。`forEach`方法不会跳过`undefined`和`null`，但会跳过空位。

- `filter`方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为`true`的成员组成一个新数组返回。该方法不会改变原数组。`filter`方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。

- `reduce`方法和`reduceRight`方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，`reduce`是从左到右处理（从第一个成员到最后一个成员），`reduceRight`则是从右到左（从最后一个成员到第一个成员），其他完全一样。`reduce`方法和`reduceRight`方法的第一个参数都是一个函数。该函数接受以下四个参数。

  1. 累积变量，默认为数组的第一个成员
  2. 当前变量，默认为数组的第二个成员
  3. 当前位置（从0开始）
  4. 原数组

  这四个参数之中，只有前两个是必须的，后两个则是可选的。

  如果要对累积变量指定初值，可以把它放在`reduce`方法和`reduceRight`方法的第二个参数。

- `indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回`-1`。`indexOf`方法还可以接受第二个参数，表示搜索的开始位置。

- `lastIndexOf`方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回`-1`。

### 包装对象

- 

