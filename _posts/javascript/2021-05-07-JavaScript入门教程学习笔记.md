---
layout: post
title: JavaScript入门教程学习笔记
date: 2021-05-07
author: 贱子
tags: [JavaScript]
---

这是[JavaScript入门教程](https://wangdoc.com/javascript/index.html)的学习笔记，摘抄了其中自己不太了解或者比较掌握薄弱的知识点。

<!--more-->

## 发展历史

- 1997年7月，ECMAScript 1.0发布。
- 1998年6月，ECMAScript 2.0版发布。
- 1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。
- 2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。
- 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。
- 2009年12月，ECMAScript 5.0版 正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。
- 2011年6月，ECMAScript 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。
- 2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。
- 2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。
- 2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为“ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。

## 基本语法

- 如果使用`var`重新声明一个已经存在的变量，是无效的。
- JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。

## 数据类型

- `typeof`运算符可以返回一个值的数据类型。
  - 数值、字符串、布尔值分别返回`number`、`string`、`boolean`。
  - 函数返回`function`。
  - `undefined`返回`undefined`。
  - 对象返回`object`。
  - `null`返回`object`。
- `undefined`和`null`，在`if`语句中，它们都会被自动转为`false`，相等运算符（`==`）甚至直接报告两者相等。
- 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为`false`，其他值都视为`true`。
  - `undefined`
  - `null`
  - `false`
  - `0`
  - `NaN`
  - `""`或`''`（空字符串）
- `NaN`不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于`Number`，使用`typeof`运算符可以看得很清楚。`NaN`不等于任何值，包括它本身。
- `Infinity`大于一切数值（除了`NaN`），`-Infinity`小于一切数值（除了`NaN`）。`Infinity`与`NaN`比较，总是返回`false`。

### 对象

- 查看一个对象本身的所有属性，可以使用`Object.keys`方法。
- `delete`命令用于删除对象的属性，删除成功后返回`true`。删除一个不存在的属性，`delete`不报错，而且返回`true`。`delete`命令只能删除对象本身的属性，无法删除继承的属性。
- `in`运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。它的左边是一个字符串，表示属性名，右边是一个对象。
- 可以使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。
- `for...in`循环用来遍历一个对象的全部属性。
  - 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
  - 它不仅遍历对象自身的属性，还遍历继承的属性。
- 如果`with`区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。`with`语句的格式如下，它的作用是操作同一个对象的多个属性时，提供一些书写的方便。（不建议使用）

```javascript
with (对象) {
  语句;
}
var obj = {
  p1: 1,
  p2: 2,
};
with (obj) {
  p1 = 4;
  p2 = 5;
}
// 等同于
obj.p1 = 4;
obj.p2 = 5;
```

### 函数

- 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。

- 函数的`name`属性返回函数的名字。如果是通过变量赋值定义的函数，那么`name`属性返回变量名。

- 函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。

- 函数的`toString()`方法返回一个字符串，内容是函数的源码。

- 对于`var`命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。

- 与全局作用域一样，函数作用域内部也会产生“变量提升”现象。`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

- 如果有同名的参数，则取最后出现的那个值。函数`f()`有两个参数，且参数名都是`a`。取值的时候，以后面的`a`为准，即使后面的`a`没有值或被省略，也是以其为准。

- `arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。

- 严格模式下，`arguments`对象与函数参数不具有联动关系。也就是说，修改`arguments`对象不会影响到实际的函数参数。

- `arguments`对象带有一个`callee`属性，返回它所对应的原函数。

- 闭包就是能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如`f2`记住了它诞生的环境`f1`，所以从`f2`可以得到`f1`的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

- 闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。

- 闭包的另一个用处，是封装对象的私有属性和私有方法。

- 外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

- 为了避免解析的歧义，JavaScript 规定，如果`function`关键字出现在行首，一律解释成语句。因此，引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，不能直接调用，所以就报错了。

  函数定义后立即调用的解决方法，就是不要让`function`出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。

### 数组

- `length`属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到`length`设置的值。
- 清空数组的一个有效方法，就是将`length`属性设为0。
- 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响`length`属性的值。将数组的键分别设为字符串和小数，结果都不影响`length`属性。因为，`length`属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以`length`属性保持为`0`。
- 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。
- `for...in`不仅会遍历数组所有的数字键，还会遍历非数字键。
- 数组如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。
- “类似数组的对象”的根本特征，就是具有`length`属性。只要有`length`属性，就可以认为这个对象类似于数组。但是有一个问题，这种`length`属性不是动态值，不会随着成员的变化而变化。

## 运算符

### 算数运算符

- 指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。
- 指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。

### 比较运算符

- 对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

- 任何值（包括`NaN`本身）与`NaN`使用非相等运算符进行比较，返回的都是`false`。

- 如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法。

- `undefined`和`null`与自身严格相等。

- ```javascript
  undefined == undefined // true
  null == null // true
  undefined == null // true
  ```

## 语法专题

### 数据类型的转换

- 使用`Number`函数，可以将任意类型的值转化成数值。

  - `Number`函数将字符串转为数值，要比`parseInt`函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`。
  - `parseInt`逐个解析字符，而`Number`函数整体转换字符串的类型。
  - `parseInt`和`Number`函数都会自动过滤一个字符串前导和后缀的空格。
  - `Number`方法的参数是对象时，将返回`NaN`，除非是包含单个数值的数组。

- `String`函数可以将任意类型的值转化成字符串。

- `Boolean()`函数可以将任意类型的值转为布尔值。

- ```javascript
  Boolean(false) // false
  Boolean(new Boolean(false)) // true
  ```

### 错误处理机制

- `Error()`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。抛出`Error`实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。
- 大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。
  - **message**：错误提示信息
  - **name**：错误名称（非标准属性）
  - **stack**：错误的堆栈（非标准属性）
- `SyntaxError`对象是解析代码时发生的语法错误。
- `ReferenceError`对象是引用一个不存在的变量时发生的错误。
- `RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。
- `TypeError`对象是变量或参数不是预期类型时发生的错误。
- `URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。
- `throw`语句的作用是手动中断程序执行，抛出一个错误。`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。
- `try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。
- 没有`catch`语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行`finally`代码块，然后再向用户提示报错信息。
- `return`语句的执行是排在`finally`代码之前，只是等`finally`代码执行完毕后才返回。

### console 对象与控制台

- `dir`方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。

- `console.assert`方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。

  它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为`false`，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。

- `time`方法表示计时开始，`timeEnd`方法表示计时结束。它们的参数是计时器的名称。调用`timeEnd`方法之后，控制台会显示“计时器名称: 所耗费的时间”。

## 标准库

### Object对象

- 虽然用法相似，但是`Object(value)`与`new Object(value)`两者的语义是不同的，`Object(value)`表示将`value`转成一个对象，`new Object(value)`则表示新生成一个对象，它的值是`value`。
- 静态方法
  - `Object.keys`方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。
  - `Object.getOwnPropertyNames`方法与`Object.keys`类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。
  - `Object.keys`方法只返回可枚举的属性，`Object.getOwnPropertyNames`方法还返回不可枚举的属性名。
- 实例方法
  - `valueOf`方法的作用是返回一个对象的“值”，默认情况下返回对象本身。`valueOf`方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。
  - `toString`方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。
  - `hasOwnProperty`方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。

### 属性描述对象

- JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。

  - `value`是该属性的属性值，默认为`undefined`。
  - `writable`是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为`true`。如果原型对象的某个属性的`writable`为`false`，那么子对象将无法自定义这个属性。
  - `enumerable`是一个布尔值，表示该属性是否可遍历，默认为`true`。如果设为`false`，会使得某些操作（比如`for...in`循环、`Object.keys()`）跳过该属性。如果一个属性的`enumerable`为`false`，下面三个操作不会取到该属性。
    - `for..in`循环
    - `Object.keys`方法
    - `JSON.stringify`方法
  - `configurable`是一个布尔值，表示可配置性，默认为`true`。如果设为`false`，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（`value`属性除外）。也就是说，`configurable`属性控制了属性描述对象的可写性。`writable`只有在`false`改为`true`会报错，`true`改为`false`是允许的。
  - `get`是一个函数，表示该属性的取值函数（getter），默认为`undefined`。
  - `set`是一个函数，表示该属性的存值函数（setter），默认为`undefined`。

- `Object.getOwnPropertyDescriptor()`方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。只能用于对象自身的属性，不能用于继承的属性。

- `Object.defineProperty()`方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。

  ```javascript
  var obj = Object.defineProperty({}, 'p', {
    value: 123,
    writable: false,
    enumerable: true,
    configurable: false
  });
  ```

- 如果一次性定义或修改多个属性，可以使用`Object.defineProperties()`方法。

  ```javascript
  var obj = Object.defineProperties({}, {
    p1: { value: 123, enumerable: true },
    p2: { value: 'abc', enumerable: true },
    p3: { get: function () { return this.p1 + this.p2 },
      enumerable:true,
      configurable:true
    }
  });
  ```

- 一旦定义了取值函数`get`（或存值函数`set`），就不能将`writable`属性设为`true`，或者同时定义`value`属性，否则会报错。

- `Object.defineProperty()`和`Object.defineProperties()`参数里面的属性描述对象，`writable`、`configurable`、`enumerable`这三个属性的默认值都为`false`。

- 实例对象的`propertyIsEnumerable()`方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回`false`。

- `Object.preventExtensions`方法可以使得一个对象无法再添加新的属性。

- `Object.isExtensible`方法用于检查一个对象是否使用了`Object.preventExtensions`方法。也就是说，检查是否可以为一个对象添加属性。

- `Object.seal`方法使得一个对象既无法添加新属性，也无法删除旧属性。`Object.seal`实质是把属性描述对象的`configurable`属性设为`false`，因此属性描述对象不再能改变了。

- `Object.isSealed`方法用于检查一个对象是否使用了`Object.seal`方法。

- `Object.freeze`方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。

- `Object.isFrozen`方法用于检查一个对象是否使用了`Object.freeze`方法。

- 使用`Object.freeze`方法以后，`Object.isSealed`将会返回`true`，`Object.isExtensible`返回`false`。

- 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。

- 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。

### Array对象

- `Array.isArray`方法返回一个布尔值，表示参数是否为数组。它可以弥补`typeof`运算符的不足。

- `join()`方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。

- `concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。

- `reverse`方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。

- `slice()`方法用于提取目标数组的一部分，返回一个新数组，原数组不变。

  ```javascript
  arr.slice(start, end);
  ```

  它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。

- `splice()`方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。

  ```javascript
  arr.splice(start, count, addElement1, addElement2, ...);
  ```

  `splice`的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。

- `map`方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。`map`方法接受一个函数作为参数。该函数调用时，`map`方法向它传入三个参数：当前成员、当前位置和数组本身。`map`方法不会跳过`undefined`和`null`，但是会跳过空位。

- `forEach`方法与`map`方法很相似，也是对数组的所有成员依次执行参数函数。但是，`forEach`方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用`map`方法，否则使用`forEach`方法。`forEach`方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用`for`循环。`forEach`方法不会跳过`undefined`和`null`，但会跳过空位。

- `filter`方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为`true`的成员组成一个新数组返回。该方法不会改变原数组。`filter`方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。

- `reduce`方法和`reduceRight`方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，`reduce`是从左到右处理（从第一个成员到最后一个成员），`reduceRight`则是从右到左（从最后一个成员到第一个成员），其他完全一样。`reduce`方法和`reduceRight`方法的第一个参数都是一个函数。该函数接受以下四个参数。

  1. 累积变量，默认为数组的第一个成员
  2. 当前变量，默认为数组的第二个成员
  3. 当前位置（从0开始）
  4. 原数组

  这四个参数之中，只有前两个是必须的，后两个则是可选的。

  如果要对累积变量指定初值，可以把它放在`reduce`方法和`reduceRight`方法的第二个参数。

- `indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回`-1`。`indexOf`方法还可以接受第二个参数，表示搜索的开始位置。

- `lastIndexOf`方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回`-1`。

### 包装对象

- 某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。
- 自动转换生成的包装对象是只读的，无法修改。

### Boolean对象

- `Boolean`对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时`Boolean`就是一个单纯的工具方法。

- ```javascript
  if (Boolean(false)) {
    console.log('true');
  } // 无输出
  
  if (new Boolean(false)) {
    console.log('true');
  } // true
  
  if (Boolean(null)) {
    console.log('true');
  } // 无输出
  
  if (new Boolean(null)) {
    console.log('true');
  } // true
  ```

### Number对象

- `Number`对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。

  作为构造函数时，它用于生成值为数值的对象。作为工具函数时，它可以将任何类型的值转为数值。

- `Number`对象部署了自己的`toString`方法，用来将一个数值转为字符串形式。

  - `toString`方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。

- `toFixed()`方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。

- `toExponential`方法用于将一个数转为科学计数法形式。`toExponential`方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。

### String对象

- `concat`方法用于连接两个字符串，返回一个新字符串，不改变原字符串。
- `slice()`方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果省略第二个参数，则表示子字符串一直到原字符串结束。
- `trim`方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（`\t`、`\v`）、换行符（`\n`）和回车符（`\r`）。
- `match`方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回`null`。返回的数组还有`index`属性和`input`属性，分别表示匹配字符串开始的位置和原始字符串。如果正则表达式带有`g`修饰符，则该方法与正则对象的`exec`方法行为不同，会一次性返回所有匹配成功的结果。设置正则表达式的`lastIndex`属性，对`match`方法无效，匹配总是从字符串的第一个字符开始。
- `search`方法的用法基本等同于`match`，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回`-1`。
- `replace`方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有`g`修饰符的正则表达式）。
- `split`方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。
  - 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。
  - 如果省略参数，则返回数组的唯一成员就是原字符串。
  - 如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。
  - 如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。
  - `split`方法还可以接受第二个参数，限定返回数组的最大成员数。

### Math对象

- `Math.floor`方法返回小于或等于参数值的最大整数（地板值）。
- `Math.ceil`方法返回大于或等于参数值的最小整数（天花板值）。
- `Math.round`方法用于四舍五入。
- `Math.random()`返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。

### Date对象

- `Date`对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。注意，即使带有参数，`Date`作为普通函数使用时，返回的还是当前时间。
- `Date`实例求值的时候，默认调用的是`toString()`方法。
- 类型自动转换时，`Date`实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。
- `Date.now`方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。
- `Date.parse`方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。
- `Date.UTC`方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。
- `valueOf`方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于`getTime`方法。

### RegExp对象

- 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。另一种是使用`RegExp`构造函数。
- 修饰符属性，用于了解设置了什么修饰符。
  - `RegExp.prototype.ignoreCase`：返回一个布尔值，表示是否设置了`i`修饰符。
  - `RegExp.prototype.global`：返回一个布尔值，表示是否设置了`g`修饰符。
  - `RegExp.prototype.multiline`：返回一个布尔值，表示是否设置了`m`修饰符。
  - `RegExp.prototype.flags`：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。
- 其他属性
  - `RegExp.prototype.lastIndex`：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。
  - `RegExp.prototype.source`：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。
- `test`方法返回一个布尔值，表示当前模式是否能匹配参数字符串。
- 正则实例对象的`exec()`方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回`null`。
  - 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的`length`属性等于组匹配的数量再加1。
  - 返回数组还包含以下两个属性：
    - `input`：整个原字符串。
    - `index`：模式匹配成功的开始位置（从0开始计数）。
  - 如果正则表达式加上`g`修饰符，则可以使用多次`exec()`方法，下一次搜索的位置从上一次匹配成功结束的位置开始。
  - 只要`exec()`方法不返回`null`，就会一直循环下去，每次输出匹配的位置和匹配的文本。
- 字符串实例对象的`match`方法对字符串进行正则匹配，返回匹配结果。
  - 字符串的`match`方法与正则对象的`exec`方法非常类似：匹配成功返回一个数组，匹配失败返回`null`。
  - 如果正则表达式带有`g`修饰符，则该方法与正则对象的`exec`方法行为不同，会一次性返回所有匹配成功的结果。
  - 设置正则表达式的`lastIndex`属性，对`match`方法无效，匹配总是从字符串的第一个字符开始。

## 面向对象编程

### 实例对象与new命令

- JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。
- JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。
- 构造函数的特点有两个。
  - 函数体内部使用了`this`关键字，代表了所要生成的对象实例。
  - 生成对象的时候，必须使用`new`命令。
- `new`命令的作用，就是执行构造函数，返回一个实例对象。
- 使用`new`命令时，它后面的函数依次执行下面的步骤。
  1. 创建一个空对象，作为将要返回的对象实例。
  2. 将这个空对象的原型，指向构造函数的`prototype`属性。
  3. 将这个空对象赋值给函数内部的`this`关键字。
  4. 开始执行构造函数内部的代码。
- 如果构造函数内部有`return`语句，而且`return`后面跟着一个对象，`new`命令会返回`return`语句指定的对象；否则，就会不管`return`语句，返回`this`对象。
- `return`语句返回一个数值时，`new`命令就会忽略这个`return`语句，返回“构造”后的`this`对象。
- 如果`return`语句返回的是一个跟`this`无关的新对象，`new`命令会返回这个新对象，而不是`this`对象。这一点需要特别引起注意。
- 函数内部可以使用`new.target`属性。如果当前函数是`new`命令调用，`new.target`指向当前函数，否则为`undefined`。

### this关键字

- 不管是什么场合，`this`都有一个共同点：它总是返回一个对象。简单说，`this`就是属性或方法“当前”所在的对象。

- 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，`this`就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

- `this`主要有以下几个使用场合。

  - 全局环境使用`this`，它指的就是顶层对象`window`。
  - 构造函数中的`this`，指的是实例对象。
  - 如果对象的方法里面包含`this`，`this`的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变`this`的指向。

- 函数实例的`call`方法，可以指定函数内部`this`的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。

  ```javascript
  var obj = {};
  var f = function () {
    return this;
  };
  f() === window // true
  f.call(obj) === obj // true
  ```

- `call`方法的参数，应该是一个对象。如果参数为空、`null`和`undefined`，则默认传入全局对象。

- 如果`call`方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入`call`方法。

- `call`方法还可以接受多个参数。`call`的第一个参数就是`this`所要指向的那个对象，后面的参数则是函数调用时所需的参数。

- `apply`方法的作用与`call`方法类似，也是改变`this`指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。

  ```javascript
  func.apply(thisValue, [arg1, arg2, ...])
  ```

- 

